# 对象

## 设计模式

### 工厂模式

工厂模式可以解决创建多个对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。

``` javascript
function createPerson(name, age, job) {
  const o = new Object();	
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log(this.name);
  };

  return o;
}

const person1 = createPerson('John', 23, 'Software Engineer');
const person2 = createPerson('Greg', 40, 'Doctor');

person1.sayName(); // John
person2.sayName(); // Greg
```

### 构造函数模式

实际上 `Person()` 内部的代码跟 `createPerson()` 基本是一样的，不过有以下区别。

- 没有显式地创建对象
- 属性和方法直接赋值给了 `this`
- 没有 `return`

``` javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
	}
}

const person1 = new Person('John', 23, 'Software Engineer');
const person2 = new Person('Greg', 40, 'Doctor');

person1.sayName(); // John
person2.sayName(); // Greg
```

构造函数名称的首字母一般都需要大写，非构造函数则以小写字母开头，有助于区分构造函数和普通函数。

要创建 `Person` 的实例需要使用 `new` 操作符，以这种方式调用构造函数会执行以下操作。

- 在内存中创建一个新对象
- 新对象内部的 `[[Prototype]]` 特性被赋值为构造函数的 `prototype` 属性
- 构造函数内部的 `this` 被赋值为这个新对象（即 `this` 指向新对象）
- 执行构造函数内部的代码（给新对象添加属性）
- 如果构造函数返回非空对象则返回该对象，否则返回刚创建的新对象

#### 构造函数也是函数

构造函数和普通函数唯一区别就是调用方式不同。任何函数只要使用 `new` 操作符调用就是构造函数，不使用 `new` 操作符调用的函数就是普通函数。

``` javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
	}
}

// 作为构造函数
const person = new Person('John', 23, 'Software Engineer');
person.sayName(); // John

// 作为函数调用
Person('Greg', 40, 'Doctor');
window.sayName(); // Greg

// 在另一个对象的作用域中调用
const o = new Object();
Person.call(o, 'kris', 28, 'Nurse');
o.sayName(); // kris
```

#### 构造函数的问题

构造函数定义的方法会在每个实例上都创建一遍，`person1` 和 `person2` 都有名为 `sayName()` 的方法，但这两个方法不是同一个 `Function` 实例。在 ECMAScript 中函数就是对象，因此每次定义函数时都会初始化一个对象，例如：

``` javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = new Function('console.log(this.name)'); // 逻辑等价
}
```

以这种方式创建函数会带来不同的作用域链和标识符解析，但创建新 `Function` 的机制是一样的，因此不同实例上的函数虽然同名却不相等。

``` javascript
console.log(person1.sayName == person2.sayName); // false
```

因为都是做一样的事，所以没必要定义两个不同的 `Function` 实例，况且 `this` 对象可以把函数与对象的绑定推迟到运行时，要解决这个问题可以把函数定义转移到构造函数外部：

``` javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}

function sayName() {
  console.log(this.name);
}

const person1 = new Person('John', 23, 'Software Engineer');
const person2 = new Person('Greg', 40, 'Doctor');

person1.sayName(); // John
person2.sayName(); // Greg
```

在构造函数内部，`sayName` 属性等于全局 `sayName()` 函数，这样虽然解决了相同逻辑函数重复定义的问题，但全局作用域也因此被搞乱了。如果这个对象需要多个方法就要在全局作用域中定义多个函数，这会导致自定义类型引用的代码不能很好的聚集在一起。这个新的问题可以通过原型模式来解决。

### 原型模式

``` javascript
function Person() {}

// 使用函数表达式也一样
// const Person = function() {};

Person.prototype.name = 'John';
Person.prototype.age = 23;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};

const person1 = new Person();
person1.sayName(); // John

const person2 = new Person();
person2.sayName(); // John

console.log(person1.sayName == person2.sayName) // true
```

## 原型

#### 理解原型

只要创建一个函数就会为这个函数创建一个 `prototype` 属性（指向原型对象），默认情况下所有原型对象自动获得一个 `constructor` 的属性，指回与它关联的构造函数。比如前面的例子，`Person.prototype.constructor` 指向 `Person`。

``` javascript
function Person() {}

// 声明后构造函数就有了一个与之关联的原型对象
console.log(typeof Person.prototype); // object

/**
 *  {
 *    constructor: ƒ Person()
 *    [[Prototype]]: Object
 *  }
 */
console.log(Person.prototype);

// 两者循环引用
console.log(Person.prototype.constructor === Person) // true

/**
 * 正常的原型链会终止于 Object 的原型对象
 * Object 原型的原型是 null
 */
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Person.prototype.__proto__.constructor === Object); // true
console.log(Person.prototype.__proto__.__proto__ === null); // true

/**
 * {
 *   constructor: ƒ Object()
 * 	 hasOwnProperty: ...
 *   isPrototypeOf: ...
 *   propertyIsEnumerable: ...
 *   ...
 * }
 */
console.log(Person.prototype.__proto__);

const person1 = new Person();

// 构造函数、原型对象和实例是 3 个完全不同的对象
console.log(person1 !== Person); // true
console.log(person1 !== Person.prototype); // true
console.log(Person.prototype !== Person); // true

/**
 * 实例通过 __proto__ 链接到原型对象
 * 它实际上指向隐藏特性 [[prototype]]
 *
 * 构造函数通过 prototype 属性链接到原型对象
 *
 * 实例与构造函数没有直接联系，与原型对象有直接联系
 */
console.log(person1.__proto__ === Person.prototype); // true
console.log(person1.__proto__.constructor === Person); // true

// 同一个构造函数创建的两个实例共享同一个原型对象
console.log(person1.__proto__ === person2.__proto__); // true

// instanceof 检查实例的原型链中是否包含指定构造函数的原型
console.log(person1 instanceof Person); // true
console.log(person1 instanceof Object); // true
console.log(Person.prototype instanceof Object); // true
```

