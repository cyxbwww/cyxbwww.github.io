# 对象

## 设计模式

### 工厂模式

工厂模式可以解决创建多个对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。

``` javascript
function createPerson(name, age, job) {
  const o = new Object();	
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log(this.name);
  };

  return o;
}

const person1 = createPerson('John', 23, 'Software Engineer');
const person2 = createPerson('Greg', 40, 'Doctor');

person1.sayName(); // John
person2.sayName(); // Greg
```

### 构造函数模式

实际上 `Person()` 内部的代码跟 `createPerson()` 基本是一样的，不过有以下区别。

- 没有显式地创建对象
- 属性和方法直接赋值给了 `this`
- 没有 `return`

``` javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
	}
}

const person1 = new Person('John', 23, 'Software Engineer');
const person2 = new Person('Greg', 40, 'Doctor');

person1.sayName(); // John
person2.sayName(); // Greg
```

构造函数名称的首字母一般都需要大写，非构造函数则以小写字母开头，有助于区分构造函数和普通函数。

要创建 `Person` 的实例需要使用 `new` 操作符，以这种方式调用构造函数会执行以下操作。

- 在内存中创建一个新对象
- 新对象内部的 `[[Prototype]]` 特性被赋值为构造函数的 `prototype` 属性
- 构造函数内部的 `this` 被赋值为这个新对象（即 `this` 指向新对象）
- 执行构造函数内部的代码（给新对象添加属性）
- 如果构造函数返回非空对象则返回该对象，否则返回刚创建的新对象

#### 构造函数也是函数

构造函数和普通函数唯一区别就是调用方式不同。任何函数只要使用 `new` 操作符调用就是构造函数，不使用 `new` 操作符调用的函数就是普通函数。

``` javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
	}
}

// 作为构造函数
const person = new Person('John', 23, 'Software Engineer');
person.sayName(); // John

// 作为函数调用
Person('Greg', 40, 'Doctor');
window.sayName(); // Greg

// 在另一个对象的作用域中调用
const o = new Object();
Person.call(o, 'kris', 28, 'Nurse');
o.sayName(); // kris
```

#### 构造函数的问题

构造函数定义的方法会在每个实例上都创建一遍，`person1` 和 `person2` 都有名为 `sayName()` 的方法，但这两个方法不是同一个 `Function` 实例。在 ECMAScript 中函数就是对象，因此每次定义函数时都会初始化一个对象，例如：

``` javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = new Function('console.log(this.name)'); // 逻辑等价
}
```

以这种方式创建函数会带来不同的作用域链和标识符解析，但创建新 `Function` 的机制是一样的，因此不同实例上的函数虽然同名却不相等。

``` javascript
console.log(person1.sayName == person2.sayName); // false
```

因为都是做一样的事，所以没必要定义两个不同的 `Function` 实例，况且 `this` 对象可以把函数与对象的绑定推迟到运行时，要解决这个问题可以把函数定义转移到构造函数外部：

``` javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}

function sayName() {
  console.log(this.name);
}

const person1 = new Person('John', 23, 'Software Engineer');
const person2 = new Person('Greg', 40, 'Doctor');

person1.sayName(); // John
person2.sayName(); // Greg
```

在构造函数内部，`sayName` 属性等于全局 `sayName()` 函数，这样虽然解决了相同逻辑函数重复定义的问题，但全局作用域也因此被搞乱了。如果这个对象需要多个方法就要在全局作用域中定义多个函数，这会导致自定义类型引用的代码不能很好的聚集在一起。这个新的问题可以通过原型模式来解决。

### 原型模式

``` javascript
function Person() {}

// 使用函数表达式也一样
// const Person = function() {};

Person.prototype.name = 'John';
Person.prototype.age = 23;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};

const person1 = new Person();
person1.sayName(); // John

const person2 = new Person();
person2.sayName(); // John

console.log(person1.sayName == person2.sayName) // true
```

## 原型

#### 理解原型

只要创建一个函数就会为这个函数创建一个 `prototype` 属性（指向原型对象），默认情况下所有原型对象自动获得一个 `constructor` 的属性，指回与它关联的构造函数。比如前面的例子，`Person.prototype.constructor` 指向 `Person`。

``` javascript
function Person() {}

// 声明后构造函数就有了一个与之关联的原型对象
console.log(typeof Person.prototype); // object

/**
 *  {
 *    constructor: ƒ Person()
 *    [[Prototype]]: Object
 *  }
 */
console.log(Person.prototype);

// 两者循环引用
console.log(Person.prototype.constructor === Person) // true

/**
 * 正常的原型链会终止于 Object 的原型对象
 * Object 原型的原型是 null
 */
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Person.prototype.__proto__.constructor === Object); // true
console.log(Person.prototype.__proto__.__proto__ === null); // true

/**
 * {
 *   constructor: ƒ Object()
 * 	 hasOwnProperty: ...
 *   isPrototypeOf: ...
 *   propertyIsEnumerable: ...
 *   ...
 * }
 */
console.log(Person.prototype.__proto__);

const person1 = new Person();

// 构造函数、原型对象和实例是 3 个完全不同的对象
console.log(person1 !== Person); // true
console.log(person1 !== Person.prototype); // true
console.log(Person.prototype !== Person); // true

/**
 * 实例通过 __proto__ 链接到原型对象
 * 它实际上指向隐藏特性 [[prototype]]
 *
 * 构造函数通过 prototype 属性链接到原型对象
 *
 * 实例与构造函数没有直接联系，与原型对象有直接联系
 */
console.log(person1.__proto__ === Person.prototype); // true
console.log(person1.__proto__.constructor === Person); // true

// 同一个构造函数创建的两个实例共享同一个原型对象
console.log(person1.__proto__ === person2.__proto__); // true

// instanceof 检查实例的原型链中是否包含指定构造函数的原型
console.log(person1 instanceof Person); // true
console.log(person1 instanceof Object); // true
console.log(Person.prototype instanceof Object); // true
```

#### 原型层级

通过对象访问属性时会按照属性的名称开始搜索。搜索开始于对象实例本身，实例上有给定的名称则返回对应的值，没有找到搜索会沿着指针进入原型对象，找到后返回对应的值。

如果在实例上添加一个与原型对象同名的属性，那就会在实例上创建这个属性。

``` javascript
function Person() {}

Person.prototype.name = 'John';
Person.prototype.age = 23;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};

const person1 = new Person();
const person2= new Person();

person1.name = 'Greg';
console.log(person1.name); // Greg 来自实例
console.log(person2.name); // John 来自原型

/**
 * 给对象实例添加一个属性，这个属性会遮蔽原型对象上的同名属性
 * 即使把这个属性设置为 null也不会恢复它和原型的联系
 * 使用 delete 可以完全删除实例上的这个属性
 */
delete person1.name;
console.log(person1.name); // John 来自原型
```

#### 属性枚举顺序

`for-in` 循环、[Object.keys()](/blog/javascript/对象内置方法.md#keys)、[Object.getOwnPropertyNames()](/blog/javascript/对象内置方法.md#getownpropertynames)、[Object.getOwnPropertySymbols()](/blog/javascript/对象内置方法.md#getownpropertysymbols) 和 [Object.assign()](/blog/javascript/对象内置方法.md#assign) 在属性枚举顺序方面有很大区别。`for-in` 循环和 `Object.keys()` 的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。

`Object.getOwnPropertyNames()`、`Object.getOwnPorpertySymbols()` 和 `Object.assign()` 的枚举顺序是确定性的。先以升序枚举数值键，然后以插入枚举字符串和符号键。在对象字面量中定义的键以他们的逗号分隔的顺序插入。

``` javascript
const k1 = Symbol('k1');
const k2 = Symbol('k2');

const o = {
  1: 1,
  first: 'first',
  [k1]: 'sym2',
  second: 'second',
  0: 0
}

o[k2] = 'sym2';
o[3] = 3;
o.third = 'third';
o[2] = 2;

// ['0', '1', '2', '3', 'first', 'second', 'third']
console.log(Object.getOwnPropertyNames(o));

// [Symbol(k1), Symbol(k2)]
console.log(Object.getOwnPropertySymbols(o));
```

#### 原型的问题

弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。但最主要的问题源自它的共享特性。

``` javascript
function Person() {}

Person.prototype = {
  constructor: Person,
	name: 'John',
	age: 23,
	job: 'Software Engineer',
	friends: ['Shelby', 'Court'],
	sayName() {
    console.log(this.name);
	}
}

const person1 = new Person()
const person2 = new Person()

person1.friends.push('Van');

console.log(person1.friends); // ['Shelby', 'Court', 'Van']
console.log(person2.friends); // ['Shelby', 'Court', 'Van']
console.log(person1.friends === person2.friends); // true
```

如果这是有意在多个实例间共享数组没什么问题，但一般来说不同的实例应该有属于自己的属性脚本。所以这是实际开发中通常不单独使用原型模式的原因。
