# 函数
## 箭头函数

``` javascript
const arrowSum = (a, b) => {
  return a + b;
};
 
const functionExpressionSum = function(a, b) {
  return a + b;
};
 
console.log(arrowSum(2, 3)); // 5
console.log(functionExpressionSum(2, 3)); // 5
```

箭头函数简洁的语法更适合嵌入函数的场景。

``` javascript
const ints = [1, 2, 3];
 
// [2, 3, 4]
console.log(ints.map(function (i) { return i + 1 }));
 
// [2, 3, 4]
console.log(ints.map((i) => { return i + 1 }));
```

如果只有一个参数，也可以不用括号。没有参数或有多个参数才需要使用括号。

``` javascript
// 以下两种写法都有效
const double = (x) => { return 2 * x };
const triple = x => { return 3 * x };
 
// 没有参数需要括号
const getRandom = () => { return Math.random() };
 
// 多个参数需要括号
const sum = (a, b) => { return a + b };
 
// 无效写法
const multiply = a, b => { return a * b };
```

也可以不使用大括号。使用大括号说明包含“函数体”，可以在一个函数中包含多条语句。不适用大括号箭头后面就只能有一行代码，省略大括号会隐式返回这行代码的值。

``` javascript
// 以下两种写法都有效且返回相应的值
const double = (x) => { return 2 * x };
const triple = x => 3 * x;
 
// 可以赋值
const value = {};
const setName = x => x.name = 'Matt';
setName(value);
 
// Matt
console.log(value.name);
 
// 无效写法
const multiply = (a, b) => return a * b;
```

箭头函数不能使用 `arguments`、`super` 和 `new.target`，也不能用作构造函数，也没有 `prototype` 属性。

## 函数名

因为函数名就是指向函数的指针，所以它们跟其它包含对象指针的变量具有相同的行为。意味着一个函数可以有多个名称。

``` javascript
function sum(num1, num2) {
  return num1 + num2;
}
console.log(sum(10, 10)); // 20

const anotherSum = sum;
console.log(anotherSum(10, 10)); // 20
 
sum = null;
console.log(anotherSum(10, 10)); // 20
```

> 使用不带括号的函数名会访问函数指针，而不会执行函数。

ECMAScript 6 的所有函数对象都会暴露一个只读的 `name` 属性。多数情况下这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。计数函数没有名称，也会显示成空字符串。如果是shiyong `function` 构造函数创建的，则会被标识成 `anonymous`。

``` javascript
function foo() {}
const bar = function() {};
const baz = () => {};
 
console.log(foo.name); // foo
console.log(bar.name); // bar
console.log(baz.name); // baz
console.log((() => {}).name); // 空字符串
console.log((new Function()).name); // anonymous
```

如果函数是一个获取函数、设置函数，或者使用 `bind()` 实例化，那么标示符前面会加上一个前缀。

``` javascript
function foo() {}
 
console.log(foo.bind(null).name); // bound foo
 
const dog = {
  years: 1,
  get age() {
    return this.years;
  },
  set age(newAge) {
    this.years = newAge;
  }
};
 
const propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age');
console.log(propertyDescriptor.get.name); // get age
console.log(propertyDescriptor.set.name); // set age
```

## 理解参数

ECMAScript 函数的参数在内部表现为一个数组。在使用 `function` 关键字定义（非箭头）函数时，可以在函数内部访问 `arguments` 对象，从中取得传进来的每个参数值。

`arguments` 对象是一个类数组对象（但不是 `Array` 的实例），因此可以使用中括号语法访问其中的元素。

``` javascript
function sayHi(name, message) {
  console.log('Hi ' + name + ', ' + message);
}
 
sayHi('Matt', 'bye'); // Hello Matt, bye
 
function sayHello() {
  console.log('Hello ' + arguments[0] + ', ' + arguments[1]);
}
 
sayHi('John', 'bye'); // Hello John, bye
```

可以使用 `arguments.length` 确定传金多少个参数。

``` javascript
function howManyArgs() {
  console.log(arguments.length);
}
 
howManyArgs('string', 66); // 2
howManyArgs(); // 0
howManyArgs(98); // 1
```

### 箭头函数中的参数

如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 `arguments` 关键字访问，只能通过定义的命名参数访问。

``` javascript
const bar = () => {
  console.log(arguments[0]);
};
 
bar(5); // ReferenceError: arguments is not defined
```

## 函数内部

在 ECMAScript 5 中，函数内部存在两个特殊函数：`arguments` 和 `this`。ECMAScript 6 新增了 `new.target` 属性。

### arguments

`arguments` 是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有 `function` 关键字定义函数（相对于使用箭头语法创建函数）时才会有。`arguments` 对象实际还有一个 `callee` 属性，是一个指向 `arguments` 对象所在函数的指针。

``` javascript
function factorial(num) {
  if(num <= 1) {
    return 1;
  } else {
    return num * factorial(num - 1);
  }
}
```

上面的例子中，只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是这个函数要正确执行就必须保证函数名是 `factorial`，从而导致了紧密耦合。使用 `arguments.callee` 可以让函数逻辑与函数名解耦。

``` javascript
function factorial(num) {
  if(num <= 1) {
    return 1;
  } else {
    return num * arguments.callee(num - 1);
  }
}
 
const trueFactorial = factorial;
 
factorial = function() {
  return 0;
};
 
console.log(trueFactorial(5)); // 120
console.log(factorial(5)); // 0
```

`trueFactorial` 变量被赋值为 `factorial`，实际上把同一个函数的指针又保存到另一个位置。然后 `factorial` 函数又被重写成一个返回 0 的函数。如果像 `factorial()` 最初的版本那样不使用 `arguments.callee`，那么像上面这样调用 `trueFactorial()` 就会返回 0。通过函数与名称解耦，`trueFactorial()` 就可以正确计算阶乘，而 `factorial()` 则只能返回 0。

### this

在标准函数中，`this` 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 `this` 值（在网页的全局上下文中调用函数时，`this` 指向 `windows`）。

``` javascript
window.color = 'red';
 
const o = {
  color: 'blue'
};
 
function sayColor() {
  console.log(this.color);
}
 
sayColor(); // red
 
o.sayColor = sayColor;
o.sayColor(); //blue
```

定义在全局上下文的函数 `sayColor()` 引用了 `this` 对象。这个 `this` 引用哪个对象需要函数被调用时才能确定。如果在全局上下文中调用， `this` 指向 `window`，`this.color` 相当于 `window.color`。而在把 `sayColor()` 赋值给 `o` 之后调用 `o.sayColor()`，`this` 会指向 `o`，`this.color` 相当于 `o.color`。

在箭头函数中，`this` 引用的是定义箭头函数的上下文。在 `sayColor()` 的两次调用中，`this` 引用的都是 `window` 对象，因为这个箭头函数是在 `window` 上下文中定义的。

``` javascript
window.color = 'red';
 
const o = {
  color: 'blue'
};
 
const sayColor = () => console.log(this.color);
 
sayColor(); // red
 
o.sayColor = sayColor;
o.sayColor(); //red
```

> 函数名只是保存指针的变量。因此全局定义的 `sayColor()` 函数和 `o.sayColor()` 是同一个函数，只不过执行的上下文不同。

在事件回调或定时回调中调用某个函数时，`this` 值指向的并非想要的对象。将回调函数写成箭头函数就可以解决问题。因为箭头函数中的 `this` 会保留定义该函数时的上下文。

``` javascript
function King() {
  this.royaltyName = 'Henry';
 
  // this 引用 King 的实例
  setTimeout(() => console.log(this.royaltyName), 1000);
}
 
function Queen() {
  this.royaltyName = 'Henry';
 
  // this 引用 Window 对象
  setTimeout(function() { console.log(this.royaltyName)}, 1000);
}
 
new King(); // Henry
new Queen(); // undefined
```

### caller

这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 `null`。

``` javascript
function outer() {
  inner();
}
 
function inner() {
  console.log(inner.caller);
}
 
outer();
```

以上代码会显示 `outer()` 函数的源代码。这是因为 `outer()` 调用了 `inner()`，`inner.caller` 指向 `outer()`。如果要降低耦合度，则可以通过 `arguments.callee.caller` 来引用同样的值。

``` javascript
function outer() {
  inner();
}
 
function inner() {
  console.log(arguments.callee.caller);
}
 
outer();
```

### new.target

ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6 新增了检测函数是否使用 `new` 关键字调用的 `new.target` 属性。如果函数是正常调用的，则 `new.target` 的值是 `undefined`；如果是使用 `new` 关键字调用的，则 `new.target` 将引用被调用的构造函数。

``` javascript
function King() {
  if (!new.target) {
    throw 'King must be instantiated using "new"';
  }
  console.log('King instantiated using "new"');
}
 
new King(); // King instantiated using "new"
King(); // Error: King must be instantiated using "new"
```

