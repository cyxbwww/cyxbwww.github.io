# 期约与异步函数

## 期约基础

ECMAScript 6新增的引用类型 `Promise`,可以通过 `new` 操作符来实例化。创建新期约时需要传入执行器（ executor ）函数作为参数，下面的例子使用了一个空函数对象来应付一下解释器，如果不提供执行器函数会抛出 `SyntaxError`。

``` javascript
const p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise <pending>
```

### 期约状态机

期约是一个有状态的对象，可能处于如下 3 种状态之一：

- 待定（ pending ）
- 兑现（ fulfilled，有时候也称为“解决”，resolved ）
- 拒绝（ rejected ）

**待定**（ pending ）是期约的最初始状态。在待定状态下，期约可以**落定**（ settled ）为代表成功的**兑现**（ fulfilled ）状态，或者代表失败的**拒绝**（ rejected ）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（ resolve ）还是拒绝（ reject ），甚至永远处于待定（ pending ）状态，都应该具有恰当的行为。

期约的状态是私有的，不能直接通过 JavaScript 检测到。主要是为了避免根据读取到的期约状态以同步的方式处理期约对象。另外期约的状态也不能被外部 JavaScript 代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。

## 解决值、拒绝理由及期约用例

期约主要有两大用途。首先是抽象地表示一个异步操作。期约地状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示已完成，而“拒绝”则表示没有成功完成。

某些情况下，这个状态机就是期约可以提供地最有用地信息。假设期约要向服务器发送一个 HTTP 请求。请求返回 200~299 这个范围内地状态码就足以让期约地状态变为“兑现”。如果请求返回地状态码不在这个范围内，那么就会把期约状态切换为“拒绝”。

在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应的，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。假设期约向服务器发送一个 HTTP 请求并预定会返回一个 JSON。如果请求返回范围在 200~299 的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个 JSON 字符串。如果请求返回的状态码不在 200~299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 `Error` 对象，包含着 HTTP 状态码及相关错误信息。

为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部**值**（ value ）。每个期约只要状态切换为拒绝，就会有一个私有的内部**理由**（ reason ）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 `undefined`。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。