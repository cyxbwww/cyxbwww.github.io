# 期约与异步函数

## 期约基础

ECMAScript 6新增的引用类型 `Promise`,可以通过 `new` 操作符来实例化。创建新期约时需要传入执行器（ executor ）函数作为参数，下面的例子使用了一个空函数对象来应付一下解释器，如果不提供执行器函数会抛出 `SyntaxError`。

``` javascript
const p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise <pending>
```

### 期约状态机

期约是一个有状态的对象，可能处于如下 3 种状态之一：

- 待定（ pending ）
- 兑现（ fulfilled，有时候也称为“解决”，resolved ）
- 拒绝（ rejected ）

**待定**（ pending ）是期约的最初始状态。在待定状态下，期约可以**落定**（ settled ）为代表成功的**兑现**（ fulfilled ）状态，或者代表失败的**拒绝**（ rejected ）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（ resolve ）还是拒绝（ reject ），甚至永远处于待定（ pending ）状态，都应该具有恰当的行为。

期约的状态是私有的，不能直接通过 JavaScript 检测到。主要是为了避免根据读取到的期约状态以同步的方式处理期约对象。另外期约的状态也不能被外部 JavaScript 代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。

## 解决值、拒绝理由及期约用例

期约主要有两大用途。首先是抽象地表示一个异步操作。期约地状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示已完成，而“拒绝”则表示没有成功完成。

某些情况下，这个状态机就是期约可以提供地最有用地信息。假设期约要向服务器发送一个 HTTP 请求。请求返回 200~299 这个范围内地状态码就足以让期约地状态变为“兑现”。如果请求返回地状态码不在这个范围内，那么就会把期约状态切换为“拒绝”。

在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应的，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。假设期约向服务器发送一个 HTTP 请求并预定会返回一个 JSON。如果请求返回范围在 200~299 的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个 JSON 字符串。如果请求返回的状态码不在 200~299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 `Error` 对象，包含着 HTTP 状态码及相关错误信息。

为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部**值**（ value ）。每个期约只要状态切换为拒绝，就会有一个私有的内部**理由**（ reason ）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 `undefined`。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。

## 通过执行函数控制期约状态

由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终切换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常命名为 `resolve()` 和 `reject()`。调用 `resolve*()` 会把状态切换为兑现，调用 `reject()` 会把状态切换为拒绝。另外，调用 `reject()` 也会抛出错误。

``` javascript
const p1 = new Promise((resolve, reject) => resolve());
setTimeout(console.log, 0, p1); // Promise <fulfilled>
 
const p2 = new Promise((resolve, reject) => reject());
setTimeout(console.log, 0, p2); // Primise <rejected>
// Uncaught error (in promise)
```

在前面的例子中并没有上面异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。这里的关键在于执行器函数是**同步**执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：

``` javascript
new Promise(() => setTimeout(console.log, 0, 'executor'));
setTimeout(console.log, 0, 'promise initialized');
 
// executor
// promise initialized
```

添加 `setTimeout` 可以推迟切换状态：

``` javascript
const p = new Promise((resolve, reject) => setTimeout(resolve, 1000));
 
// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）
setTimeout(console.log, 0 , p); // Promise <pending>
```

无论 `resolve()` 和 `reject()` 中的哪个被调用，状态切换都不可撤销。继续修改状态会静默失败：

``` javascript
const p = new Promise((resolve, reject) => {
  resolve();
  reject(); // 没有效果
});
 
setTimeout(console.log, 0 , p); // Promise <fulfilled>
```

## 期约的实例方法

期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。

### 实现 `Thenable` 接口

在 ECMAScript 暴露的异步结构中，任何对象都有一个 `then()` 方法。这个方法被认为实现了 `Thenable` 接口。这个例子展示了实现这一接口的最简单的类：

``` javascript
class MyThenable {
  then() {}
}
```

ECMAScript 的 `Promise` 类型实现了 `Thenable` 接口。这个简化的接口跟 TypeScript 或其他包中的接口或类型定义不同，他们都设定了 `Thenable` 接口更具体的形式。

### `Promise.prototype.then()`

`Promise.prototype.then()` 是为期约实例添加处理程序的主要方法。可以接收两个参数：`onResolved` 处理程序 和 `onRejected` 处理程序。两个参数可选，如果提供会在期约分别进入“兑现”和“拒绝”状态时执行。

 ``` javascript
 function onResolved(id) {
   setTimeout(console.log, 0, id, 'resolved');
 }
 function onRejected(id) {
   setTimeout(console.log, 0, id, 'rejected');
 }
  
 const p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000));
 const p2 = new Promise((resolve, reject) => setTimeout(reject, 3000));
  
 p1.then(() => onResolved('p1'), () => onRejected('p1'));
 p2.then(() => onResolved('p2'), () => onRejected('p2'));
  
 // 3秒后
 // p1 resolved
 // p2 rejected
 ```

传给 `then()` 的任何非函数类型的参数都会被静默忽略。如果只提供 `onRejected` 参数，那就要在 `onResolved` 参数的位置上传入 `undefined` 或 `null`。这样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。

``` javascript
function onResolved(id) {
  setTimeout(console.log, 0, id, 'resolved');
}
function onRejected(id) {
  setTimeout(console.log, 0, id, 'rejected');
}
 
const p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000));
const p2 = new Promise((resolve, reject) => setTimeout(reject, 3000));
 
// 非函数处理程序会被静默忽略，不推荐
p1.then('gobbeltygook');
 
// 不传 onResolved 处理程序的规范写法
p2.then(null, () => onRejected('p2'));
 
// 3秒后
// p2 rejected
```

### `Promise.prototype.catch()`

`Promise.prototype.catch()`  方法用于给期约添加拒绝处理程序。只接收一个参数：`onRejected` 处理程序。实际这个方法是一个语法糖，相当于调用 `Promise.prototype.then(null, onRejected)`。

### `Promise.prototype.finally()`

`Promise.prototype.finally()` 方法用于给期约添加 `onFinally` 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。可以避免 `onResolved` 和 `onRejected` 处理程序中出现冗余代码。但 `onFinally` 处理程序没办法知道期约的状态，所以这个方法主要用于添加i清理代码。
