# 代理与反射（ Proxy/Reflect ）

ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。即可以给目标对象定义一个关联的代理对象，这个代理对象可以作为抽象的目标对象来使用。在目标对象的各种操作影响目标对象前，可以在代理对象中对这些操作加以控制。

## 代理基础

代理是目标对象的抽象，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。

### 创建空代理

默认情况下，在代理对象上执行的所有操作都会无障碍的传播到目标对象。因此在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。

代理是使用 `Proxy` 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 `TypeError`。

``` javascript
const target = {
  id: 'target'
};
 
const handler = {};
 
const proxy = new Proxy(target, handler);
 
// id 属性会访问同一个值
console.log(target.id); // target
console.log(proxy.id); // target
 
// 给目标属性赋值会反映在两个对象上，因为两个对象访问的是同一个值
target.id = 'foo';
console.log(target.id); // foo
console.log(proxy.id); // foo
 
// 给代理属性赋值会反映到两个对象上，因为这个赋值会转移到目标对象
proxy.id = 'bar';
console.log(target.id); // bar
console.log(proxy.id); // bar
 
// hasOwnProperty() 方法在两个地方都会应用到目标对象
console.log(target.hasOwnProperty('id')); // true
console.log(proxy.hasOwnProperty('id')); // true
 
// Proxy.prototype 是 undefined，因此不能使用 instanceof 操作符
console.log(target instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check
console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check
 
// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false
```

### 定义捕获器

使用代理的主要目的是可以定义**捕获器**（ trap ）。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接地在代理对象上调用。

例如定义一个 `get()` 捕获器，在 ECMAScript 操作以某种形式调用 `get()` 时触发：

``` javascript
const target = {
  foo: 'bar'
};
 
const handler = {
  // 捕获器在处理程序对象中以方法名为键
  get() {
    return 'handler override';
  }
}
 
const proxy = new Proxy(target, handler);
 
console.log(target.foo); // bar
console.log(proxy.foo); // handler override
 
console.log(target['foo']); // bar
console.log(proxy['foo']); // handler override
 
console.log(Object.create(target)['foo']); // bar
console.log(Object.create(proxy)['foo']); // handler override
```

当通过代理对象执行 `get()` 操作时，就会触发定义的 `get()` 捕获器。只有在代理对象上执行操作才会触发捕获器。在目标对象上执行操作仍然会产生正常的行为。

### 捕获器参数和反射 API

所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如 `get()` 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。

``` javascript
const target = {
  foo: 'bar'
};
 
const handler = {
  get(trapTarget, property, receiver) {
    console.log(trapTarget === target);
    console.log(property);
    console.log(receiver === proxy);
  }
}
 
const proxy = new Proxy(target, handler);
 
proxy.foo;
// true
// foo
// true
```

有了这些参数，就可以重建被捕获方法的原始行为：

``` javascript
const target = {
  foo: 'bar'
};
 
const handler = {
  get(trapTarget, property, receiver) {
    return trapTarget[property]
  }
}
 
const proxy = new Proxy(target, handler);
 
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```

实际上开发者并不需要手动重建原始行为，而是通过调用全局 `Reflect` 对象上（封装了原始行为）的同名方法来轻松重建。处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。

``` javascript
const target = {
  foo: 'bar'
};
 
// const handler = {
// 	get() {
//     return Reflect.get(...arguments);
//   }
// }
 
// 更简洁的写法
const handler = {
  get: Reflect.get
}
 
const proxy = new Proxy(target, handler);
 
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```

如果真像创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象。

``` javascript
const target = {
  foo: 'bar'
};
 
const proxy = new Proxy(target, Reflect);
 
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```

### 捕获器不变式

捕获处理程序的行为必须遵循“捕获器不变式”（ trap invariant ）。捕获器不变式因方法不同而异，但通常会防止捕获器定义出现过于反常的行为。

比如如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 `TypeError`。

``` javascript
const target = {};
 
Object.defineProperty(target, 'foo', {
  configurable: false,
  writable: false,
  value: 'foo'
});
 
const handler = {
  get() {
    return 'qux';
  }
}
 
const proxy = new Proxy(target, handler);
 
// TypeError
proxy.foo;
```

### 可撤销代理

有时候可能需要中断代理对象与目标对象之间的联系。对于使用 `new Proxy()` 创建的普通代理，这种联系会在代理对象的生命周期内一直持续存在。

`Proxy` 也暴露了 `revocable()` 方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。撤销代理之后再调用代理会抛出 `TypeError`。

``` javascript
const target = {
  foo: 'bar'
};
 
const handler = {
  get() {
    return 'intercepted';
  }
};
 
const { proxy, revoke } = Proxy.revocable(target, handler);
 
console.log(proxy.foo); // intercepted
console.log(target.foo); // bar
 
revoke();
 
console.log(proxy.foo); // TypeError
```

### 实用反射 API

某些情况下应该有限使用反射 API。

#### 反射 API 与对象 API

- 反射 API 并不限于捕获处理程序
- 大多数反射 API 方法在 `Object` 类型上有对应的方法。

通常 `Object` 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。

#### 状态标记

很多反射方法返回称作“状态标记”的布尔值，标识意图执行的操作是否成功。有时候状态标记比返回修改后的对象或抛出错误的反射 API 方法更有用。例如可以使用反射 API 对下面的代码进行重构：

``` javascript
// 初始代码
 
const o = {};
 
try {
  Object.defineProperty(o, 'foo', 'bar');
  console.log('success');
} catch (e) {
  console.log('failure');
}
```

在定义新属性时如果发生问题，`Reflect.defineProperty()` 会返回 `false`，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：

``` javascript
// 重构后的代码
 
const o = {};
 
if (Reflect.defineProperty(o, 'foo', { value: 'bar' })) {
  console.log('success');
} else {
  console.log('failure');
}
```

以下反射方法都会提供状态标记：

- `Reflect.defineProperty()`
- `Reflect.preventExtensions()`
- `Reflect.setPrototypeOf()`
- `Reflect.set()`
- `Reflect.deleteProperty()`

#### 用一等函数替代操作符

以下反射方法提供只有通过操作符才能完成的操作：

- `Reflect.get()`：可以替代对象属性访问操作符
- `Reflect.set()`：可以替代=赋值操作符
- `Reflect.has()`：可以替代 `in` 操作符或 `with()`
- `Reflect.deleteProperty()`：可以替代 `delete` 操作符
- `Reflect.construct()`：可以替代 `new` 操作符

### 代理另一个代理

代理可以拦截反射 API 的操作，意味着完全可以创建一个代理，通过它去代理另一个代理。这样可以在一个目标对象上构建多层拦截网：

``` javascript
const target = {
  foo: 'bar'
};
 
const firstProxy = new Proxy(target, {
  get() {
    console.log('first proxy');
    return Reflect.get(...arguments);
  }
})
 
const secondProxy = new Proxy(firstProxy, {
  get() {
    console.log('second proxy');
    return Reflect.get(...arguments);
  }
})
 
console.log(secondProxy.foo);
// second proxy
// first proxy
// bar
```

## 代理捕获器与反射方法

代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。

### `get()`

`get()` 捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 `Reflect.get()`。

``` javascript
const myTarget = {};
 
const proxy = new Proxy(myTarget, {
  get(target, property, receiver) {
    console.log('get()');
    return Reflect.get(...arguments);
  }
});
 
// get()
proxy.foo;
```

#### 返回值

返回值无限制

#### 拦截的操作

- `proxy.property`
- `proxy[property]`
- `Object.create(proxy)[property]`
- `Reflect.get(proxy, property, receiver)`

#### 捕获器处理程序参数

- `target`：目标对象
- `property`：引用的目标对象上的字符串属性
- `receiver`：代理对象或继承代理对象的对象

#### 捕获器不变式

如果 `target.property` 不可写且不可配置，则处理程序返回的值必须与 `target.property` 匹配。

如果 `target.property` 不可配置且 `[[Get]]` 特性为 `undefined`，处理程序的返回值也必须是 `undefined`。

### `set()`

`set()` 捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 `Reflect.set()`。

``` javascript
const myTarget = {};

const proxy = new Proxy(myTarget, {
  set(target, property, receiver) {
    console.log('set()');
    return Reflect.set(...arguments);
  }
});
 
// set()
proxy.foo = 'bar';
```

#### 返回值

返回 `true` 标识成功；返回 `false` 表示失败，严格模式下会抛出 `TypeError`。

#### 拦截的操作

- `Proxy.property = value`
- `proxy[property] = value`
- `Object.create(proxy)[property] = value`
- `Reflect.set(proxy, property, value, receiver)`

#### 捕获器处理程序参数

- `target`：目标对象
- `property`：引用的目标对象上的字符串键属性
- `value`：要赋给属性的值
- `receiver`：接受最初赋值的对象

#### 捕获器不变式

如果 `target.property` 不可写切不可配置，则不能修改目标属性的值。

如果 `target.property` 不可配置且 `[[Set]]` 特性为 `undefined`，则不能修改目标属性的值。

在严格模式下，处理程序中返回 `false` 会抛出 `TypeError`。

### `has()`

`has()` 捕获器会在 `in` 操作符中被调用。对应的反射 API 方法为 `Reflect.has()`。

``` javascript
const myTarget = {};
 
const proxy = new Proxy(myTarget, {
  has(target, property) {
    console.log('has()');
    return Reflect.has(...arguments);
  }
});
 
// has()
'foo' in proxy;
```

#### 返回值

`has()` 必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。

#### 拦截的操作

- `property in  proxy`
- `property in Object.create(proxy)`
- `with(proxy) { (property); }`
- `Reflect.has(proxy, property)`

#### 捕获器处理程序参数

- `target`：目标对象
- `property`：引用的目标对象上的字符串键属性

#### 捕获器不变式

如果 `target.property` 存在且不可配置，则处理程序必须返回 `true`。

如果 `target.property` 存在且目标对象不可扩展，则处理程序必须返回 `true`。

### `defineProperty()`

`defineProperty()` 捕获器会在 `Object.defineProperty()` 中被调用。对应的反射 API 方法为 `Reflect.defineProperty()`。

``` javascript
const myTarget = {};
 
const proxy = new Proxy(myTarget, {
  defineProperty(target, property, descriptor) {
    console.log('defineProperty()');
    return Reflect.defineProperty(...arguments);
  }
});
 
// defineProperty()
Object.defineProperty(proxy, 'foo', { value: 'bar' });
```

#### 返回值

`defineProperty()` 必须返回布尔值，表示属性是否定义成功。返回非布尔值会被转型为布尔值。

#### 拦截的操作

- `Object.defineProperty(proxy, property, descriptor)`
- `Reflect.defineProperty(proxy, property, descriptor)`

#### 捕获器处理程序参数

- `target`：目标对象
- `property`：引用的目标对象上的字符串键属性
- `descriptor`：包含可选的 `enumerable`、`configurable`、`writable`、`value`、`get` 和 `set` 定义的对象

#### 捕获器不变式

如果目标对象不可扩展，则无法定义属性。

如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。

如果目标有一个不可配置的属性，则不能添加同名的可配置属性。

### `getOwnPropertyDescriptor()`

`getOwnPropertyDescriptor()` 捕获器会在 `Object.getOwnPropertyDescriptor()` 中被调用。对应的反射 API 为 `Reflect.getOwnPropertyDescriptor()`。

``` javascript
const myTarget = {};
 
const proxy = new Proxy(myTarget, {
  getOwnPropertyDescriptor(target, property, descriptor) {
    console.log('getOwnPropertyDescriptor()');
    return Reflect.getOwnPropertyDescriptor(...arguments);
  }
});
 
// getOwnPropertyDescriptor()
Object.getOwnPropertyDescriptor(proxy, 'foo');
```

#### 返回值

`getOwnPropertyDescriptor()` 必须返回对象，或者在属性不存在时返回 `undefined`。

#### 拦截的操作

- `Object.getOwnPropertyDescriptor(proxy, property)`
- `Reflect.getOwnPropertyDescriptor(proxy, property)`

#### 捕获器处理程序参数

- `target`：目标对象
- `property`：引用的目标对象上的字符串键属性

#### 捕获器不变式

如果自有的 `target.property` 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。

如果自有的 `target.property` 存在且可配置，则处理程序必须返回表示该属性可配置的对象。

如果 `target.property` 不存在且 `target` 不可扩展，则处理程序必须返回 `undefined` 表示该属性不存在。

如果 `target.property` 不存在，则处理程序不能返回表示该属性可配置的对象。

### `deleteProperty()`

`deleteProperty()` 捕获器会在 `delete` 操作符中被调用。对应的反射 API 方法为 `Reflect.deleteProperty()`。

``` javascript
const myTarget = {};
 
const proxy = new Proxy(myTarget, {
  deleteProperty(target, property) {
    console.log('deleteProperty()');
    return Reflect.deleteProperty(...arguments);
  }
});
 
// deleteProperty()
delete proxy.foo
```

#### 返回值

`deleteProperty()` 必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。

#### 拦截的操作

- `delete proxy.property`
- `delete proxy[property]`
- `Reflect.deleteProperty(proxy, property)`

#### 捕获器处理程序参数

- `target`：目标对象
- `property`：引用的目标对象上的字符串键属性

#### 捕获器不变式

如果自有的 `target.property` 存在且不可配置，则处理程序不能删除这个属性。

### `ownKeys()`

`ownKeys()` 捕获器会在 `Object.keys()` 及类似方法中被调用。对应的反射 API 方法为 `Reflect.ownKeys()`。

``` javascript
const myTarget = {};
 
const proxy = new Proxy(myTarget, {
  ownKeys(target) {
    console.log('ownKeys()');
    return Reflect.ownKeys(...arguments);
  }
});
 
// ownKeys()
Object.keys(proxy)
```

#### 返回值

`ownKeys()` 必须返回包含字符串或符号的可枚举对象。

#### 拦截的操作

- `Object.getOwnPropertyNames(proxy)`
- `Object.getOwnPropertySymbols(proxy)`
- `Object.keys(proxy)`
- `Reflect.ownKeys(proxy)`

#### 捕获器处理程序参数

- `target`：目标对象

#### 捕获器不变式

返回的可枚举对象必须包含 `target` 的所有不可配置的自有属性。

如果 `target` 不可扩展，则返回可枚举对象必须准确地包含自有属性键。

### `getPrototypeOf()`

`getPrototypeOf()` 捕获器会在 `Object.getPrototypeOf()` 中被调用。对应的反射 API 方法为 `Reflect.getPrototypeOf()`。

``` javascript
const myTarget = {};

const proxy = new Proxy(myTarget, {
  getPrototypeOf(target) {
    console.log('getPrototypeOf()');
    return Reflect.getPrototypeOf(...arguments);
  }
});
 
// getPrototypeOf()
Object.getPrototypeOf(proxy);
```

#### 返回值

`getPrototypeOf()` 必须返回对象或 `null`。

#### 拦截的操作

- `Object.getPrototypeOf(proxy)`
- `Reflect.getPrototypeOf(proxy)`
- `proxy.__proto__`
- `Object.prototype.isPrototypeOf(proxy)`
- `proxy instanceof Object`

#### 捕获器处理程序参数

- `target`：目标对象

#### 捕获器不变式

如果 `target` 不可扩展，则 `Object.getPrototypeOf(proxy)` 唯一有效的返回值就是 `Object.getPrototypeOf(target)` 的返回值。

### `setPrototypeOf()`

`setPrototypeOf()` 捕获器会在 `Object.setPrototypeOf()` 中被调用。对应的反射 API 方法为 `Reflect.setPrototypeOf()`。

``` javascript
const myTarget = {};

const proxy = new Proxy(myTarget, {
  setPrototypeOf(target) {
    console.log('setPrototypeOf()');
    return Reflect.setPrototypeOf(...arguments);
  }
});
 
// setPrototypeOf()
Object.setPrototypeOf(proxy, Object);
```

#### 返回值

`setPrototypeOf()` 必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。

#### 拦截的操作

- `Object.setPrototypeOf(proxy)`
- `Reflect.setPrototypeOf(proxy)`

#### 捕获器处理程序参数

- `target`：目标对象
- `prototype`：`target` 的替代原型，如果是顶级原型则为 `null`

#### 捕获器不变式

如果 `target` 不可扩展，则唯一有效的 `prototype` 参数就是 `Object.getPrototypeOf(target)` 的返回值。

### `isExtensible()`

`isExtensible()` 捕获器会在 `Object.isExtensible()` 中被调用。对应的反射 API 方法为 `Reflect.isExtensible()`。

``` javascript
const myTarget = {};

const proxy = new Proxy(myTarget, {
  isExtensible(target) {
    console.log('isExtensible()');
    return Reflect.isExtensible(...arguments);
  }
});
 
// isExtensible()
Object.isExtensible(proxy);
```

#### 返回值

`isExtensible()` 必须返回布尔值，表示 `target` 是否可扩展。返回非布尔值会被转型为布尔值。

#### 拦截的操作

- `Object.isExtensible(proxy)`
- `Reflect.isExtensible(proxy)`

#### 捕获器处理程序参数

- `target`：目标对象

#### 捕获器不变式

如果 `target` 可扩展，则处理程序必须返回 `true`。

如果 `target` 不可扩展，则处理程序必须返回 `false`。

### `preventExtensions()`

`preventExtensions()` 捕获器会在 `Object.preventExtensions()` 中被调用。对应的反射 API 方法为 `Reflect.preventExtensions()`。

``` javascript
const myTarget = {};

const proxy = new Proxy(myTarget, {
  preventExtensions(target) {
    console.log('preventExtensions()');
    return Reflect.preventExtensions(...arguments);
  }
});
 
// preventExtensions()
Object.preventExtensions(proxy);
```

#### 返回值

`preventExtensions()` 必须返回布尔值，表示 `target` 是否已经不可扩展。返回非布尔值会被转型为布尔值。

#### 拦截的操作

- `Object.preventExtensions(proxy)`
- `Reflect.preventExtensions(proxy)`

#### 捕获器处理程序参数

- `target`：目标对象

#### 捕获器不变式

如果 `Object.preventExtensions(proxy)` 是 `false`，则处理程序必须返回 `true`。 

### `apply()`

`apply()` 捕获器会在调用函数时被调用。对应的反射 API 方法为 `Reflect.apply()`。

``` javascript
const myTarget = () => {};

const proxy = new Proxy(myTarget, {
  apply(target, thisArg, ...arguments) {
    console.log('apply()');
    return Reflect.preventExtensions(...arguments);
  }
});
 
// apply()
proxy();
```

#### 返回值

返回值无限制。

#### 拦截的操作

- `proxy(...argumentsList)`
- `Function.prototype.apply(thisArg, argumentsList)`
- `Function.prototype.call(thisArg, ...argumentsList)`
- `Reflect.apply(target, thisArg, ...argumentsList)`

#### 捕获器处理程序参数

- `target`：目标对象
- `thisArg`：调用函数时的 `this` 参数
- `argumentsList`：调用函数时的参数列表

#### 捕获器不变式

`target` 必须是一个函数对象。

### `construct()`

`construct()` 捕获器会在 `new` 操作符中被调用。对应的反射 API 方法为 `Reflect.construct()`。

``` javascript
const myTarget = function() {};

const proxy = new Proxy(myTarget, {
  construct(target, argumentsList, newTarget) {
    console.log('construct()');
    return Reflect.construct(...arguments);
  }
});
 
// construct()
new proxy();
```

#### 返回值

`construct()` 必须返回一个对象。

#### 拦截的操作

- `new proxy(...argumentsList)`
- `Reflect.construct(target, argumentsList, newTarget)`

#### 捕获器处理程序参数

- `target`：目标构造函数
- `argumentsList`：传给目标构造函数的参数列表
- `newTarget`：最初被调用的构造函数

#### 捕获器不变式

`target` 必须可以用作构造函数。
