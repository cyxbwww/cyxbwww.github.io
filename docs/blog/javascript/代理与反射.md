# 代理与反射（ Proxy/Reflect ）

ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。即可以给目标对象定义一个关联的代理对象，这个代理对象可以作为抽象的目标对象来使用。在目标对象的各种操作影响目标对象前，可以在代理对象中对这些操作加以控制。

## 代理基础

代理是目标对象的抽象，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。

### 创建空代理

默认情况下，在代理对象上执行的所有操作都会无障碍的传播到目标对象。因此在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。

代理是使用 `Proxy` 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 `TypeError`。

``` javascript
const target = {
  id: 'target'
};
 
const handler = {};
 
const proxy = new Proxy(target, handler);
 
// id 属性会访问同一个值
console.log(target.id); // target
console.log(proxy.id); // target
 
// 给目标属性赋值会反映在两个对象上，因为两个对象访问的是同一个值
target.id = 'foo';
console.log(target.id); // foo
console.log(proxy.id); // foo
 
// 给代理属性赋值会反映到两个对象上，因为这个赋值会转移到目标对象
proxy.id = 'bar';
console.log(target.id); // bar
console.log(proxy.id); // bar
 
// hasOwnProperty() 方法在两个地方都会应用到目标对象
console.log(target.hasOwnProperty('id')); // true
console.log(proxy.hasOwnProperty('id')); // true
 
// Proxy.prototype 是 undefined，因此不能使用 instanceof 操作符
console.log(target instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check
console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check
 
// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false
```

### 定义捕获器

使用代理的主要目的是可以定义**捕获器**（ trap ）。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接地在代理对象上调用。

例如定义一个 `get()` 捕获器，在 ECMAScript 操作以某种形式调用 `get()` 时触发：

``` javascript
const target = {
  foo: 'bar'
};
 
const handler = {
  // 捕获器在处理程序对象中以方法名为键
  get() {
    return 'handler override';
  }
}
 
const proxy = new Proxy(target, handler);
 
console.log(target.foo); // bar
console.log(proxy.foo); // handler override
 
console.log(target['foo']); // bar
console.log(proxy['foo']); // handler override
 
console.log(Object.create(target)['foo']); // bar
console.log(Object.create(proxy)['foo']); // handler override
```

当通过代理对象执行 `get()` 操作时，就会触发定义的 `get()` 捕获器。只有在代理对象上执行操作才会触发捕获器。在目标对象上执行操作仍然会产生正常的行为。

### 捕获器参数和反射 API

所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如 `get()` 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。

``` javascript
const target = {
  foo: 'bar'
};
 
const handler = {
  get(trapTarget, property, receiver) {
    console.log(trapTarget === target);
    console.log(property);
    console.log(receiver === proxy);
  }
}
 
const proxy = new Proxy(target, handler);
 
proxy.foo;
// true
// foo
// true
```

有了这些参数，就可以重建被捕获方法的原始行为：

``` javascript
const target = {
  foo: 'bar'
};
 
const handler = {
  get(trapTarget, property, receiver) {
    return trapTarget[property]
  }
}
 
const proxy = new Proxy(target, handler);
 
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```

实际上开发者并不需要手动重建原始行为，而是通过调用全局 `Reflect` 对象上（封装了原始行为）的同名方法来轻松重建。处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。

``` javascript
const target = {
  foo: 'bar'
};
 
// const handler = {
// 	get() {
//     return Reflect.get(...arguments);
//   }
// }
 
// 更简洁的写法
const handler = {
  get: Reflect.get
}
 
const proxy = new Proxy(target, handler);
 
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```

如果真像创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象。

``` javascript
const target = {
  foo: 'bar'
};
 
const proxy = new Proxy(target, Reflect);
 
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```

### 捕获器不变式

捕获处理程序的行为必须遵循“捕获器不变式”（ trap invariant ）。捕获器不变式因方法不同而异，但通常会防止捕获器定义出现过于反常的行为。

比如如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 `TypeError`。

``` javascript
const target = {};
 
Object.defineProperty(target, 'foo', {
  configurable: false,
  writable: false,
  value: 'foo'
});
 
const handler = {
  get() {
    return 'qux';
  }
}
 
const proxy = new Proxy(target, handler);
 
// TypeError
proxy.foo;
```

