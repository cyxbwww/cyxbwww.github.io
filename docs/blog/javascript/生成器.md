# 生成器

生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。使用迭代器可以自定义迭代器和实现协程。

## 生成器基础

生成器的形式是一个函数，函数名称前面加一个星号（ * ）表示它是一个生成器。只要是可以定义函数的地方就可以定义生成器。

``` javascript
// 生成器函数声明
function* generatorFn() {}
 
// 生成器函数表达式
const generatorFn = function* () {}
 
// 作为对象字面量方法的生成器函数
const foo = {
  * generatorFn() {}
}
 
// 作为类实例方法的生成器函数
class Foo {
  * generatorFn() {}
}
 
// 作为类静态方法的生成器函数
class Bar {
  static * generatorFn() {}
}
```

> 箭头函数不能用来定义生成器函数。

标识生成器函数的星号不受两侧空格的影响：

``` javascript
// 等价的生成器函数
function* generatorFnA() {}
function *generatorFnB() {}
function * generatorFnC() {}
 
// 等价的生成器方法
class Foo {
  *generatorFnD() {}
  * generatorFnE() {}
}
```

调用生成器函数会产生一个**生成器对象**。生成器对象一开始处于暂停执行（ suspended ）的状态。与迭代器相似，生成器对象也实现了 `Iterator` 接口，因此具有 `next()` 方法。调用这个方法会让生成器开始或恢复执行。

``` javascript
function* generatorFn() {}
 
const g = generatorFn();
 
console.log(g); // generatorFn {<suspended>}
console.log(g.next); // ƒ next() { [native code] }
```

`next()` 方法的返回值类似于迭代器，有一个 `done` 属性和一个 `value` 属性。函数体为空的生成器函数中间不会停留，调用一次 `next()` 就会让生成器到达 `done: true` 状态。

``` javascript
function* generatorFn() {}
 
const generatorObject = generatorFn();
 
console.log(generatorObject); // generatorFn {<suspended>}
console.log(generatorObject.next()); // { value: undefined, done: true }
```

`value` 属性是生成器函数的返回值，默认值为 `undefined`，可以通过生成器函数的返回值指定：

``` javascript
function* generatorFn() {
  return 'foo';
}
 
const generatorObject = generatorFn();
 
console.log(generatorObject); // generatorFn {<suspended>}
console.log(generatorObject.next()); // { value: 'foo', done: true }
```

生成器函数只会在初次调用 `next()` 方法后开始执行：

``` javascript
function* generatorFn() {
  console.log('foobar');
}
 
// 初次调用生成器函数并不会打印日志
const generatorObject = generatorFn();
 
generatorObject.next(); // foobar
```

生成器对象实现了 `Iterable` 接口，它们默认的迭代器是自引用的：

``` javascript
function* generatorFn() {}
 
console.log(generatorFn); // ƒ* generatorFn() {}
console.log(generatorFn()[Symbol.iterator]); // ƒ [Symbol.iterator]() { [native code] }
console.log(generatorFn()); // generatorFn {<suspended>}
console.log(generatorFn()[Symbol.iterator]()); // generatorFn {<suspended>}
 
const g = generatorFn();
 
// true
console.log(g === g[Symbol.iterator]());
```

