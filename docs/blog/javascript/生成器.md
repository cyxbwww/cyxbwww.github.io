# 生成器

生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。使用迭代器可以自定义迭代器和实现协程。

## 生成器基础

生成器的形式是一个函数，函数名称前面加一个星号（ * ）表示它是一个生成器。只要是可以定义函数的地方就可以定义生成器。

``` javascript
// 生成器函数声明
function* generatorFn() {}
 
// 生成器函数表达式
const generatorFn = function* () {}
 
// 作为对象字面量方法的生成器函数
const foo = {
  * generatorFn() {}
}
 
// 作为类实例方法的生成器函数
class Foo {
  * generatorFn() {}
}
 
// 作为类静态方法的生成器函数
class Bar {
  static * generatorFn() {}
}
```

> 箭头函数不能用来定义生成器函数。

标识生成器函数的星号不受两侧空格的影响：

``` javascript
// 等价的生成器函数
function* generatorFnA() {}
function *generatorFnB() {}
function * generatorFnC() {}
 
// 等价的生成器方法
class Foo {
  *generatorFnD() {}
  * generatorFnE() {}
}
```

调用生成器函数会产生一个**生成器对象**。生成器对象一开始处于暂停执行（ suspended ）的状态。与迭代器相似，生成器对象也实现了 `Iterator` 接口，因此具有 `next()` 方法。调用这个方法会让生成器开始或恢复执行。

``` javascript
function* generatorFn() {}
 
const g = generatorFn();
 
console.log(g); // generatorFn {<suspended>}
console.log(g.next); // ƒ next() { [native code] }
```

`next()` 方法的返回值类似于迭代器，有一个 `done` 属性和一个 `value` 属性。函数体为空的生成器函数中间不会停留，调用一次 `next()` 就会让生成器到达 `done: true` 状态。

``` javascript
function* generatorFn() {}
 
const generatorObject = generatorFn();
 
console.log(generatorObject); // generatorFn {<suspended>}
console.log(generatorObject.next()); // { value: undefined, done: true }
```

`value` 属性是生成器函数的返回值，默认值为 `undefined`，可以通过生成器函数的返回值指定：

``` javascript
function* generatorFn() {
  return 'foo';
}
 
const generatorObject = generatorFn();
 
console.log(generatorObject); // generatorFn {<suspended>}
console.log(generatorObject.next()); // { value: 'foo', done: true }
```

生成器函数只会在初次调用 `next()` 方法后开始执行：

``` javascript
function* generatorFn() {
  console.log('foobar');
}
 
// 初次调用生成器函数并不会打印日志
const generatorObject = generatorFn();
 
generatorObject.next(); // foobar
```

生成器对象实现了 `Iterable` 接口，它们默认的迭代器是自引用的：

``` javascript
function* generatorFn() {}
 
console.log(generatorFn); // ƒ* generatorFn() {}
console.log(generatorFn()[Symbol.iterator]); // ƒ [Symbol.iterator]() { [native code] }
console.log(generatorFn()); // generatorFn {<suspended>}
console.log(generatorFn()[Symbol.iterator]()); // generatorFn {<suspended>}
 
const g = generatorFn();
 
// true
console.log(g === g[Symbol.iterator]());
```

## 通过 `yield` 中断执行

`yield` 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 `yield` 关键字之前会正常执行。遇到后执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 `next()` 方法来恢复执行。

``` javascript
function* generatorFn() {
  yield;
}
 
const generatorObject = generatorFn();
 
console.log(generatorObject.next()); // { value: undefined, done: false }
console.log(generatorObject.next()); // { value: undefined, done: true }
```

### 生成器对象作为可迭代对象

在生成器对象上显式调用 `next()` 方法的用处并不大。如果把生成器对象当成可迭代对象，那么使用起来会更方便。

``` javascript
function* generatorFn() {
  yield 1;
  yield 2;
  yield 3;
}
 
for (const x of generatorFn()) {
  console.log(x);
}
 
// 1
// 2
// 3
```

在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现：

``` javascript
function* nTimes(n) {
  while(n--) {
    yield;
  }
}
 
for (const _ of nTimes(3)) {
  console.log('foo');
}
 
// foo
// foo
// foo
```

传给生成器的函数可以控制迭代循环的次数。在 `n` 为 0 时，`while` 条件为假，循环退出，生成器函数返回。
