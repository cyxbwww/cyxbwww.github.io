# 响应系统

## 4. 响应系统的作用与实现

### 4.1 响应式数据与副作用函数

副作用函数指的是会产生副作用的函数：

``` javascript
function effect() {
	document.body.innerText = 'hellow vue3';
}
```

当 `effect` 函数执行时，它会设置 `body` 的文本内容，但除了 `effect` 函数之外的任何函数都可以读取或设置 `body` 的文本内容。也就是说 `effect` 函数的执行会直接或间接影响其它函数的执行，这是我们说 `effect` 函数产生了副作用。副作用很容易产生，例如一个函数修改了全局变量，这也是一个副作用：

``` javascript
// 全局变量
let val = 1;
 
function effect() {
  val = 2; // 修改全局变量，产生副作用
}
```

理解了声明式副作用函数，再来说看看什么是响应式数据，假设在一个副作用函数中读取了某个对象的属性：

``` javascript
const obj = {
  text: 'hello world'
};
 
function effect() {
  document.body.innerText = obj.text;
}
```

上面的代码中，副作用函数 `effect` 会设置 `body` 元素的 `innerText` 属性，其值为 `obj.text`，当 `obj.text` 的值发生变化时，我们希望副作用函数 `effect` 会重新执行：

``` javascript
obj.text = 'hello vue3'; // 修改 obj.text 的值，同时希望副作用函数会重新执行
```

这里修改了字段 `obj.text` 的值，我们希望当值发生变化后，副作用函数自动重新执行，如果能实现这个目标，那么对象 `obj` 就是响应式数据。

### 4.2 响应式数据的基本实现

如何让 `obj` 变成响应式数据呢？通过观察我们能发现：

- 当副作用函数 `effect` 执行时，会触发字段 `obj.text` 的**读取操作**
- 当修改 `obj.text` 的值时，会触发字段 `obj.text` 的**设置**操作

如果我们能拦截一个对象的读取和设置操作，事情就变得简单了。在 ES2015 之前，我们只能通过 `Object.defineProperty` 函数实现，这是 Vue.js2 所采用的方式。在 ES2015+ 中，我们可以使用代理对象 `Proxy` 来实现，这是 Vue.js3 所采用的方式。

``` javascript
// 存储副作用函数的容器
const bucket = new Set();
 
// 原始数据
const data = {
  text: 'hello world'
};
 
// 对原始数据的代理
const obj = new Proxy(data, {
  // 拦截读取操作
	get(target, key) {
    // 将副作用函数 effect 添加到储存副作用函数的容器中
    bucket.add(effect);
		// 返回属性值
    return target[key];
	},
	// 拦截设置操作
	set(target, key, newVal) {
    // 设置属性值
		target[key] = newVal;
    // 把副作用函数从容器中取出并执行
		bucket.forEach(fn => fn());
    // 返回 true 代表设置操作成功
		return true
	}
});

// 副作用函数
function effect() {
  document.body.innerText = obj.text;
}

// 执行副作用函数，触发读取
effect();
 
// 1 秒后修改响应式数据
setTimeout(() => {
  obj.text = 'hello vue3';
}, 1000);
```

上面的实现还存在很多缺陷，这里我们只需要理解响应式数据的基本实现和工作原理即可。

### 4.3 设计一个完善的响应系统

从上面的例子中可以看出一个响应系统的工作流程如下：

- 当**读取**操作发生时，将副作用函数收集到容器中
- 当**设置**操作发生时，从容器中取出副作用函数并执行
