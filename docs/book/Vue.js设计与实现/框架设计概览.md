# 框架设计概览

## 1. 权衡的艺术

### 1.1 命令式与声明式

从范式上看，视图层框架通常分为命令式和声明式。

早些时候流行的 jQuery 就是典型的命令式框架。命令式框架的一大特点就是**关注过程**。例如我们把下面这段话翻译成对应的代码：

``` text
- 获取 id 为 app 的 div 标签
- 它的文本内容为 hello world
- 为其绑定点击事件
- 当点击时弹出提示：ok
```

对应的代码为：

``` javascript
$('#app') // 获取 div
	.text('hello world') // 设置文本内容
	.on('click', () => alert('ok')); // 绑定点击事件
```

以上是 jQuery 的代码示例，我们再用原生 JavaScript 来实现同样的功能：

``` javascript
const div = document.querySelector('#app'); // 获取 div
div.innerText = 'hello world'; // 设置文本内容
div.addEventListener('click', () => alert('ok')); // 绑定点击事件
```

自然语言描述能与代码产生一一对应的关系，代码本身描述的是“做事的过程”，这符合我们的逻辑直觉。

声明式框架更加**关注结果**。结合 Vue.js，我们可以这样实现上面自然语言描述的功能：

``` vue
<div @click="() => alert('ok')">hello world</div>
```

这段类 HTML 的模板就是 Vue.js 实现上面功能的方式。可以看到这里提供的是一个“结果”，实现该“结果”的**过程**则是由 Vue.js 帮我们完成的。换句话说，Vue.js 帮我们封装了**过程**。因此，我们能够猜到 Vue.js 的内部实现一定是**命令式**的，而暴露给用户的却更加**声明式**。

### 1.2 性能与可维护性的权衡

**声明式代码的性能不优于命令式代码的性能**。假设我们要将 `div` 标签的文本内容修改为 hello vue3，可以使用命令式代码实现：

``` javascript
div.textContent = 'hello vue3';
```

理论上命令式代码可以做到极致的性能优化，因为我们明确知道哪些发生了变更，只做必要的修改就行了。但是声明式代码不一定能做到这一点，因为它描述的是结果：

``` vue
<!-- 之前 -->
<div @click="() => alert('ok')">hello world</div>
<!-- 之后 -->
<div @click="() => alert('ok')">hello vue3</div>
```

对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并指更新变化的地方，但是最终完成这次更新的代码仍然是：

``` javascript
div.textContent = 'hellow vue3'; // 直接修改
```

如果我们把直接修改的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有：

- 命令式代码的更新性能消耗 = A
- 声明式代码的更新性能消耗 = B + A

声明式代码会比命令式代码多出找出差异的性能消耗，因此最理想的情况是，当找出差异的性能消耗为 0 时，声明式代码与命令式代码的性能相同，但是无法做到超越，**毕竟框架本身就是封装了命令式代码才实现了面向用户的声明式**。

Vue.js 选择声明式的设计方案原因在于可维护性更强。在采用命令式代码开发的时候，我们需要维护实现目标的整个**过程**，包括要手动完成 DOM 元素的创建、更新、删除等工作。而声明式代码展示的就是我们要的**结果**。

这体现了在框架设计上要做出的关于可维护性与性能之间的权衡。在采用声明式提升可维护性的同时，性能就会有一定的损失，而框架设计者要做的就是：**在保持可维护性的同时让新跟那个损失最小化**。

### 1.3 虚拟 DOM 的性能

从上一章我们知道，**声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗**，因此，如果我们能够最小化**找出差异的性能消耗**，就可以让声明式代码的性能无限接近命令式代码的性能。而虚拟 DOM，就是为了**最小化**找出差异这一步的性能消耗而出现的。

前面所说的原生 JavaScript 实际上值得是像 `document.createElement` 之类的 DOM 操作方法，并不包含 `innerHTML` ，那么使用 `innerHTML` 操作页面和虚拟 DOM 相比性能如何？`innerHTML` 和 `document.createElement` 等 DOM 操作方法有何差异？

为了比较 `innerHTML` 和虚拟 DOM 的性能，我们需要了解它们的创建、更新页面的过程。对于 `innerHTML` 来说，为了创建页面，我们需要构造一段 HTML 字符串：

``` javascript
const html = `<div><span>...</span></div>`;
```

接着将该字符串赋值给 DOM 元素的 `innerHTML` 属性：

``` javascript
div.innerHTML = html;
```

为了渲染出页面，首先要把字符串解析成 DOM 树，这是一个 DOM 层面的计算。涉及 DOM 的运算远比 JavaScript 层面的计算性能差。

### 1.4 运行时和编译时

### 1.5 总结

