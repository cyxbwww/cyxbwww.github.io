# 框架设计概览

## 1. 权衡的艺术

### 1.1 命令式与声明式

从范式上看，视图层框架通常分为命令式和声明式。

早些时候流行的 jQuery 就是典型的命令式框架。命令式框架的一大特点就是**关注过程**。例如我们把下面这段话翻译成对应的代码：

``` text
- 获取 id 为 app 的 div 标签
- 它的文本内容为 hello world
- 为其绑定点击事件
- 当点击时弹出提示：ok
```

对应的代码为：

``` javascript
$('#app') // 获取 div
	.text('hello world') // 设置文本内容
	.on('click', () => alert('ok')); // 绑定点击事件
```

以上是 jQuery 的代码示例，我们再用原生 JavaScript 来实现同样的功能：

``` javascript
const div = document.querySelector('#app'); // 获取 div
div.innerText = 'hello world'; // 设置文本内容
div.addEventListener('click', () => alert('ok')); // 绑定点击事件
```

自然语言描述能与代码产生一一对应的关系，代码本身描述的是“做事的过程”，这符合我们的逻辑直觉。

声明式框架更加**关注结果**。结合 Vue.js，我们可以这样实现上面自然语言描述的功能：

``` vue
<div @click="() => alert('ok')">hello world</div>
```

这段类 HTML 的模板就是 Vue.js 实现上面功能的方式。可以看到这里提供的是一个“结果”，实现该“结果”的**过程**则是由 Vue.js 帮我们完成的。换句话说，Vue.js 帮我们封装了**过程**。因此，我们能够猜到 Vue.js 的内部实现一定是**命令式**的，而暴露给用户的却更加**声明式**。

### 1.2 性能与可维护性的权衡

**声明式代码的性能不优于命令式代码的性能**。假设我们要将 `div` 标签的文本内容修改为 hello vue3，可以使用命令式代码实现：

``` javascript
div.textContent = 'hello vue3';
```

理论上命令式代码可以做到极致的性能优化，因为我们明确知道哪些发生了变更，只做必要的修改就行了。但是声明式代码不一定能做到这一点，因为它描述的是结果：

``` vue
<!-- 之前 -->
<div @click="() => alert('ok')">hello world</div>
<!-- 之后 -->
<div @click="() => alert('ok')">hello vue3</div>
```

对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并指更新变化的地方，但是最终完成这次更新的代码仍然是：

``` javascript
div.textContent = 'hellow vue3'; // 直接修改
```

如果我们把直接修改的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有：

- 命令式代码的更新性能消耗 = A
- 声明式代码的更新性能消耗 = B + A

