# 作用域和闭包

## 1. 作用域是什么

### 1.1 编译原理

在传统编译语言的流程中，程序的一段源代码在执行之前会经历三个步骤统称为“编译”。

- 分词/词法分析（ Tokenizing/Lexing ）

  这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（ token ）。

- 解析/语法分析（ Parsing ）

  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（ Abstract Syntax Tree，AST ）。

- 代码生成

  将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。

相比一些只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

JavaScript 引擎不会有大量的时间用来进行优化，因为与其它语言不同，JavaScript 的编译过程不是发生在构建之前的。

对于 JavaScript 来说大部分情况编译发生在代码执行的前几微秒的时间内。在作用域背后 JavaScript 引擎用尽了各种方法来保证性能最佳。

简单来说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。

### 1.2 理解作用域

我们将学习作用域的过程模拟成几个人物之间的对话。

#### 1.2.1 演员表

对程序 `var a = 2;` 进行处理为例。

- 引擎

  从头到尾负责整个 JavaScript 程序的编译及执行过程。

- 编译器

  引擎的好朋友之一，负责语法分析及代码生成等脏活累活（如前一节的内容）。

- 作用域

  引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行代码对这些标识符的访问权限。

#### 1.2.2 对话

当看见 `var a = 2;` 这段程序时，很可能认为这是一句声明。事实上引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。

可以合理地假设编译器所产生地代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为 `a`，然后将值 2 保存进这个变量”。这里并不完全准确。实际编译器会进行如下处理：

1. 遇到 `var a`，编译器询问作用域是否有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 `a`。
2. 接下来编译器会为引擎生成运行时的代码，这些代码被用来处理 `a = 2`这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 `a` 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

如果引擎最终找到了 `a` 变量，就会将 2 赋值给它。否则引擎会抛出一个异常。

**总结：**变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
