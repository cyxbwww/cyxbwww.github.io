# 作用域和闭包

## 1. 作用域是什么

### 1.1 编译原理

在传统编译语言的流程中，程序的一段源代码在执行之前会经历三个步骤统称为“编译”。

- 分词/词法分析（ Tokenizing/Lexing ）

  这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（ token ）。

- 解析/语法分析（ Parsing ）

  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（ Abstract Syntax Tree，AST ）。

- 代码生成

  将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。

相比一些只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

JavaScript 引擎不会有大量的时间用来进行优化，因为与其它语言不同，JavaScript 的编译过程不是发生在构建之前的。

对于 JavaScript 来说大部分情况编译发生在代码执行的前几微秒的时间内。在作用域背后 JavaScript 引擎用尽了各种方法来保证性能最佳。

简单来说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。

### 1.2 理解作用域

我们将学习作用域的过程模拟成几个人物之间的对话。

#### 1.2.1 演员表

对程序 `var a = 2;` 进行处理为例。

- 引擎

  从头到尾负责整个 JavaScript 程序的编译及执行过程。

- 编译器

  引擎的好朋友之一，负责语法分析及代码生成等脏活累活（如前一节的内容）。

- 作用域

  引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行代码对这些标识符的访问权限。

#### 1.2.2 对话

当看见 `var a = 2;` 这段程序时，很可能认为这是一句声明。事实上引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。

可以合理地假设编译器所产生地代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为 `a`，然后将值 2 保存进这个变量”。这里并不完全准确。实际编译器会进行如下处理：

1. 遇到 `var a`，编译器询问作用域是否有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 `a`。
2. 接下来编译器会为引擎生成运行时的代码，这些代码被用来处理 `a = 2`这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 `a` 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

如果引擎最终找到了 `a` 变量，就会将 2 赋值给它。否则引擎会抛出一个异常。

**总结**：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

#### 1.2.3 编译器有话说

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 `a` 来判断它是否已声明过。查找的过程由作用域进行协助，在我们的例子中，引擎会为变量 `a` 进行 LHS 查询。另外一个查找的类型叫作 LRS。

以下代码对 `a` 的引用是一个 RHS 引用，因为这里 `a` 没有赋予任何值，且需要查找并取得 `a` 的值。

``` javascript
console.log(a);
```

相比以下代码对 `a` 的引用是一个 LHS 引用，我们不关心当前值是什么，只是想要为 `= 2` 这个赋值操作找到一个目标。

``` javascript
a = 2;
```

> LHS 和 RHS 的含义是“赋值操作的左侧和右侧”并不一定意味着“ `=` 赋值操作符的左侧或右侧”。赋值操作还有其它几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（ LHS ）”以及“谁是赋值操作的源头（ RHS ）”。

下面的程序中，既有 LHS 也有 RHS 引用：

``` javascript
function foo(a) {
  // 隐式的 a = 2，进行一次 LHS 查询，
  // 并对 a 进行 RHS 引用传递给 console.log
  
  // 对 console 进行 RHS 引用，
  // 并检查得到的值是否有一个叫作 log 的方法
  // 再次对 a 进行 RHS 引用
  console.log(a);
}
 
foo(2); // 对 foo 进行 RHS 引用并执行
```

#### 1.2.4 引擎和作用域的对话

我们把上一节的代码处理过程想象成一段对话，这段对话可能是下面这样：

``` text
引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？
作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
引擎：哥们太够意思了！好吧，我来执行一下 foo。
引擎：作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？
作用域：这个也见过，编译器最近把它声明为 foo 的一个形式参数了，拿去吧。
引擎：大恩不言谢，你总是那么棒。现在我要把 2 赋值给 a。
引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？
作用域：咋俩谁跟谁啊，再说我就是干这个的。这个我也有，console 是个内置对象，给你。
引擎：么么哒。我得看看里面是不是有log()。太好了，找到了，是一个函数。
引擎：哥们，能帮我再找一下 对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。
作用域：放心吧，这个变量没有变动过，拿走，不谢。
引擎：真棒。我来把 a 的值，也就是 2，传递进 log()。
......
```

#### 1.2.5 小测验

检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”“：

``` javascript
function foo(a) {
  // 隐式的 a = 2，进行 LHS 查询
  // 对 b 进行 LHS 查询
  // 对 a 进行 RHS 引用
  var b = a;
    
  // 对 a 进行 RHS 引用
  // 对 b 进行 RHS 引用
  return a + b;
}
 

// c = ..，对 c 进行 LHS 查询
// 对 foo 进行 RHS 引用
var c = foo(2);
```

### 1.3 作用域嵌套

在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（全局作用域）为止。

``` javascript
function foo(a) {
  console.log(a + b);
}
 
var b = 2;
 
foo(2); // 4
```

这里对 `b` 进行的 RHS 引用无法在函数 `foo` 内部完成，但可以在上一级作用域中完成。

回顾一下与作用域之间的对话，会进一步听到：

``` text
引擎：foo 的作用域兄弟，你见过 b 吗？我需要对它进行 RHS 引用。
作用域：听都没听过，走开。
引擎：foo 的上级作用域兄弟，咦？有眼不识泰山，原来你是全局作用域大哥，太好了。你见过 b 吗？我需要对它进行 RHS 引用。
作用域：当然了，给你吧。
```

遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就像上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

### 1.4 异常

区分 LHS 和 RHS 是一件重要的事情，因为在变量还没有声明（在任何作用域中都无法找到改变量）的情况下，这两种查询的行为是不一样的。

``` javascript
function foo(a) {
  console.log(a + b);
  b = 2;
}
 
foo(2); // Uncaught ReferenceError: b is not defined
```

第一次对 `b` 进行 RHS 查询时是无法找到该变量的。也就是这是一个“未声明”的变量。如果 RHS 查询在所有嵌套的作用域中找不到所需变量，引擎就会抛出 `ReferenceError` 异常。

相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎，前提是程序运行在非“严格模式”下。

在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 `ReferenceError` 异常。

如果 RHS 查询找到了一个变量，但是对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用 `null` 或 `undefined` 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 `TypeError`。

`ReferenceError` 同作用域判断失败相关，而 `TypeError` 则代表作用域判别成功，但对结果的操作是非法或不合理的。

### 1.5 小结

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。

赋值操作符会导致 LHS 查询。`=` 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 `var a = 2;` 这样的声明会被分解成两个独立的步骤：

1. 首先，`var a` 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来，`a = 2`会查询（ LHS 查询 ）变量 `a` 并对其进行赋值。

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都会停止。

不成功的 RHS 引用会导致抛出 `ReferenceError` 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 `ReferenceError` 异常（严格模式下）。

## 2. 词法作用域

作用域共有两种主要的工作模型。第一种是被大多数编程语言所采用的**词法作用域**，另外一种叫作**动态作用域**。

### 2.1 词法阶段

大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

简单来说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

``` javascript
function foo(a) {
  var b = a * 2;
 
  function bar(c) {
    console.log(a, b, c);
  }
 
  bar(b * 3);
}
 
foo(2); // 2 4 12
```

在这里有三个逐级嵌套的作用域：

1. 全局作用域，其中有一个标识符：`foo`。
2. `foo` 所创建的作用域，其中有三个标识符：`a`、`b` 和 `bar`。
3. `bar` 所创建的作用域，其中有一个标识符：`c`。

#### 查找

作用域的结构和之间的关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

在上面的代码中，引擎执行 `console.log()` 声明，并查找 `a`、`b` 和 `c` 三个变量的引用。它首先从最内部的 `bar()` 函数作用域内查找。引擎无法在这里找到 `a`，因此会去上一级嵌套的 `foo()` 函数作用域内继续查找，在这里找到了 `a`，所以引擎在这里引用了 `a`。对 `b` 来讲也一样。而对 `c` 来说，引擎在 `bar()` 函数作用域内就可以找到。

如果 `bar()` 和 `foo()` 内都有 `c`，引擎就会直接使用 `bar()` 中的变量，无需到外面的 `foo()` 中查找。**作用域查找会在找到第一个匹配的标识符时停止**。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。

### 2.2 小结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

## 3. 函数作用域

### 3.1 函数中的作用域

``` javascript
function foo(a) {
  var b = 2;
 
  // 一些代码...
 
  function bar() {
    // 一些代码...
  }
 
  var c = 3;
}
```

在上面的代码中，`foo` 的作用域包含了标识符 `a`、`b`、`c` 和 `bar`。无论这个标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域。因此这里无法从 `foo()` 的外部对它们进行访问。

``` javascript
bar(); // Uncaught ReferenceError: bar is not defined

console.log(a); // a ReferenceError: bar is not defined
```

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（在嵌套的作用域中也可以使用）。

### 3.2 隐藏内部实现

从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。

有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指软件设计中，应该最小限度地暴露必要内容，而将其它内容都“隐藏”起来，比如某个模块或对象的 API 设计。

这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，可以在所有内部嵌套作用域中访问它们。但这样会破坏前面提到的最小特权原则，因为可能会暴露过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问。

``` javascript
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
 
  console.log(b * 3);
}
 
function doSomethingElse(a) {
  return a - 1;
}
 
var b;
 
doSomething(2); // 15
```

在上面的代码中，变量 `b` 和函数 `doSomethingElse()` 应该是 `doSomething()` 内部具体实现的“私有”内容。给予外部作用域对 `b` 和 `doSomethingElse()` 的“访问权限”不仅没有必要，而且可能是“危险”的，因为它们可能被有意无意地以非预期地方式使用，从而导致超出了 `doSomething()` 地适用条件。更“合理”的设计会将这些私有的具体内容隐藏在 `doSomething()` 内部：

``` javascript
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }
 
  var b;
 
  b = a + doSomethingElse(a * 2);
 
  console.log(b * 3);
}
 
doSomething(2); // 15
```

#### 隐藏实现

“隐藏”作用域中的变量和函数可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

``` javascript
function foo() {
  function bar(a) {
    i = 3; // 修改 for 循环所属作用域中的 i
    console.log(a + i);
  }
 
  for (var i = 0; i < 10; i++) {
    bar(i * 2); // 无限循环
  }
}

foo();
```

##### 1. 全局命名空间

变量冲突的一个典型例子存在于全局作用域中。当程序加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就很容易引发冲突。

这些库通常会在全局作用与中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的**命名空间**，所有需要暴露给外界的功能都会称为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

``` javascript
var MyReallyCoolLibrary = {
  awesome: 'stuff',
  doSomeThing: () => {
    // ...
  }
}
```

##### 2. 模块管理

另外一种避免冲突的方法和现代的**模块**机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定地作用域中。

### 3.3 函数作用域

我们知道，在任何代码片段外部添加包装函数，可以将内部地变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内的任何内容。

``` javascript
var a = 2;
 
function foo() {
  var a = 3;
  console.log(a); // 3
}
 
foo();
 
console.log(a); // 2
```

虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数 `foo()`，意味着 `foo` 这个名称本身“污染”了所在作用域。其次，必须显式地通过函数名 `foo()` 调用这个函数才能运行其中的代码。

如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更理想。幸好 JavaScript 提供了函数表达式的解决方案。

``` javascript
var a = 2;
 
(function() {
  var a = 3;
  console.log(a); // 3
})();
 
console.log(a); // 2
```

