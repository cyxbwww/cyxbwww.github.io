# 作用域和闭包

## 1. 作用域是什么

### 1.1 编译原理

在传统编译语言的流程中，程序的一段源代码在执行之前会经历三个步骤统称为“编译”。

- 分词/词法分析（ Tokenizing/Lexing ）

  这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（ token ）。

- 解析/语法分析（ Parsing ）

  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（ Abstract Syntax Tree，AST ）。

- 代码生成

  将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。

相比一些只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

JavaScript 引擎不会有大量的时间用来进行优化，因为与其它语言不同，JavaScript 的编译过程不是发生在构建之前的。

对于 JavaScript 来说大部分情况编译发生在代码执行的前几微秒的时间内。在作用域背后 JavaScript 引擎用尽了各种方法来保证性能最佳。

简单来说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。

### 1.2 理解作用域

我们将学习作用域的过程模拟成几个人物之间的对话。

#### 1.2.1 演员表

对程序 `var a = 2;` 进行处理为例。

- 引擎

  从头到尾负责整个 JavaScript 程序的编译及执行过程。

- 编译器

  引擎的好朋友之一，负责语法分析及代码生成等脏活累活（如前一节的内容）。

- 作用域

  引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行代码对这些标识符的访问权限。

#### 1.2.2 对话

当看见 `var a = 2;` 这段程序时，很可能认为这是一句声明。事实上引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。

可以合理地假设编译器所产生地代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为 `a`，然后将值 2 保存进这个变量”。这里并不完全准确。实际编译器会进行如下处理：

1. 遇到 `var a`，编译器询问作用域是否有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 `a`。
2. 接下来编译器会为引擎生成运行时的代码，这些代码被用来处理 `a = 2`这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 `a` 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

如果引擎最终找到了 `a` 变量，就会将 2 赋值给它。否则引擎会抛出一个异常。

**总结**：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

#### 1.2.3 编译器有话说

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 `a` 来判断它是否已声明过。查找的过程由作用域进行协助，在我们的例子中，引擎会为变量 `a` 进行 LHS 查询。另外一个查找的类型叫作 LRS。

以下代码对 `a` 的引用是一个 RHS 引用，因为这里 `a` 没有赋予任何值，且需要查找并取得 `a` 的值。

``` javascript
console.log(a);
```

相比以下代码对 `a` 的引用是一个 LHS 引用，我们不关心当前值是什么，只是想要为 `= 2` 这个赋值操作找到一个目标。

``` javascript
a = 2;
```

> LHS 和 RHS 的含义是“赋值操作的左侧和右侧”并不一定意味着“ `=` 赋值操作符的左侧或右侧”。赋值操作还有其它几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（ LHS ）”以及“谁是赋值操作的源头（ RHS ）”。

下面的程序中，既有 LHS 也有 RHS 引用：

``` javascript
function foo(a) {
  // 隐式的 a = 2，进行一次 LHS 查询，
  // 并对 a 进行 RHS 引用传递给 console.log
  
  // 对 console 进行 RHS 引用，
  // 并检查得到的值是否有一个叫作 log 的方法
  // 再次对 a 进行 RHS 引用
  console.log(a);
}
 
foo(2); // 对 foo 进行 RHS 引用并执行
```

#### 1.2.4 引擎和作用域的对话

我们把上一节的代码处理过程想象成一段对话，这段对话可能是下面这样：

``` text
引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？
作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
引擎：哥们太够意思了！好吧，我来执行一下 foo。
引擎：作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？
作用域：这个也见过，编译器最近把它声明为 foo 的一个形式参数了，拿去吧。
引擎：大恩不言谢，你总是那么棒。现在我要把 2 赋值给 a。
引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？
作用域：咋俩谁跟谁啊，再说我就是干这个的。这个我也有，console 是个内置对象，给你。
引擎：么么哒。我得看看里面是不是有log()。太好了，找到了，是一个函数。
引擎：哥们，能帮我再找一下 对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。
作用域：放心吧，这个变量没有变动过，拿走，不谢。
引擎：真棒。我来把 a 的值，也就是 2，传递进 log()。
......
```

